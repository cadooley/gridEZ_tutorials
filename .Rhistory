file_path <- paste0(getwd(),"/data_wsm/made/")
!file.exists(paste0(file_path,"strataGADM.tif"))
paste0(file_path,"strataGADM.tif")
file.exists(paste0(file_path,"strataGADM.tif"))
processing_cores <- max(parallel::detectCores() - 1, 1)
processing_cores
EZ_tab <- read.csv(paste0(file_path_outputs, "EZ_Pop_Ncells_wsm_wp_large_disttocoast.csv"),header=T)
file_path_outputs <- paste0(getwd(),"/results_wsm/")
EZ_tab <- read.csv(paste0(file_path_outputs, "EZ_Pop_Ncells_wsm_wp_large_disttocoast.csv"),header=T)
nrow(EZ_tab)
head(EZ_tab)
EZ <- terra::rast(paste0(file_path_outputs,"EZ_IDs_wsm_wp_large_disttocoast.tif"))
# plot raster
plot(EZ,main="Spatial distribution of EZs (raster)")
res_poly <- terra::as.polygons(EZ, dissolve = TRUE)
res_poly <- sf::st_as_sf(res_poly)
# merge the ppolygons and EZ IDs
res_poly <- merge(res_poly,EZ_tab,by="EZ_ID")
# plot EZ polygons coloured by EZ IDs
plot(res_poly[,"geometry"],main="Spatial distribution of EZs (polygons)")
?rainbow
cols <- sample(rainbow(nrow(EZ_tab)))
plot(EZ,main="Spatial distribution of EZs (raster)",col=cols)
cols <- sample(scico(nrow(EZ_tab), palette = "lapaz"))
plot(EZ,main="Spatial distribution of EZs (raster)",col=cols)
cols <- sample(scico(nrow(EZ_tab), palette = "tokyo"))
plot(EZ,main="Spatial distribution of EZs (raster)",col=cols)
cols <- sample(scico(nrow(EZ_tab), palette = "lajolla"))
plot(EZ,main="Spatial distribution of EZs (raster)",col=cols)
cols <- sample(rainbow(nrow(EZ_tab)))
plot(EZ,main="Spatial distribution of EZs (raster)",col=cols)
cols <- c(sample(scico(nrow(EZ_tab)/2, palette = "lajolla")),
sample(scico(nrow(EZ_tab)/2, palette = "cork")))
plot(EZ,main="Spatial distribution of EZs (raster)",col=cols)
cols <- sample(c(scico(nrow(EZ_tab)/2, palette = "lajolla"),
scico(nrow(EZ_tab)/2, palette = "cork")))
plot(EZ,main="Spatial distribution of EZs (raster)",col=cols)
cols <- sample(scico(nrow(EZ_tab)/2, palette = "broc"))
plot(EZ,main="Spatial distribution of EZs (raster)",col=cols)
plot(res_poly[,"geometry"],main="Spatial distribution of EZs (polygons)")
plot(res_poly[,"pop"],main="EZ population size")
plot(res_poly[,"pop"],main="EZ population size")
plot(res_poly[,"N"],main="EZ grid cells count")
?zonal
EZ
admin_raster <- terra::rast(paste0(file_path_inputs,"adminGADM.tif"))
file_path_inputs <- paste0(getwd(),"/data_wsm/made/")
admin_raster <- terra::rast(paste0(file_path_inputs,"adminGADM.tif"))
dist_raster <- terra::rast(paste0(file_path_inputs,"disttocoast.tif"))
EZ_strata <- data.table::data.table(EZ_ID = EZ[],
strata1 = admin_raster[],
strata2 = dist_raster[])
EZ_strata <- unique(EZ_strata)
nrow(EZ_strata)
head(EZ_strata)
EZ_strata <- na.omit(EZ_strata)
nrow(EZ_strata)
head(EZ_strata)
names
names(EZ_strata)
EZ_strata <- data.table::data.table(EZ_ID = EZ,
strata1 = admin_raster,
strata2 = dist_raster)
EZ_strata <- data.table::data.table(EZ[],
admin_raster[],
dist_raster[])
names(EZ_strata) <- c("EZ_ID","strata1","strata2")
EZ_strata <- na.omit(EZ_strata)
EZ_strata <- unique(EZ_strata)
head(EZ_strata)
tail(EZ_strata)
head(EZ_strata[order(EZ_strata$strata1),])
admin_raster
dist_raster
levels(admin_raster)[[1]]$label[admin_raster[]]
admin_f <- as.factor(admin_raster)
levels(admin_f)[[1]]$label[admin_f[]]
class(admin_f)
admin_f
EZ_strata <- data.table::data.table(EZ[],
as.character(admin_raster[]),
dist_raster[])
names(EZ_strata) <- c("EZ_ID","strata1","strata2")
# reduce table down to a single row per EZ
EZ_strata <- na.omit(EZ_strata)
EZ_strata <- unique(EZ_strata)
head(EZ_strata)
terra::cats(admin_raster)
terra::cats(admin_raster)[[1]]
terra::cats(admin_raster)
plot(admin_raster)
# as the admin_raster contains categories, we want the category labels rather than their corresponding value
admin_cats <- terra::cats(admin_raster)[[1]]
head(admin_cats)
admin_labels <- admin_cats$label[match(admin_raster[], admin_cats$value)]
admin_cats <- terra::cats(admin_raster)[[1]]
admin_labels <- admin_cats$label[match(admin_raster[], admin_cats$value)]
# as we defined the distance categories by numeric values, we can directly use those raster values
EZ_strata <- data.table::data.table(EZ[],
admin_labels,
dist_raster[])
# set column names, change as needed
names(EZ_strata) <- c("EZ_ID","strata1","strata2")
head(EZ_strata)
class(admin_labels)
head(admin_cats)
admin_cats <- terra::cats(admin_raster)[[1]]
admin_labels <- admin_cats$GID_2[match(admin_raster[], admin_cats$value)]
# as we defined the distance categories by numeric values, we can directly use those raster values
EZ_strata <- data.table::data.table(EZ[],
admin_labels,
dist_raster[])
head(EZ_strata)
]names(EZ_strata) <- c("EZ_ID","strata1","strata2")
# set column names, change as needed
names(EZ_strata) <- c("EZ_ID","strata1","strata2")
admin_cats <- terra::cats(admin_raster)[[1]]
admin_labels <- admin_cats$GID_2[match(admin_raster[], admin_cats$value)]
# as we defined the distance categories by numeric values, we can directly use those raster values
EZ_strata <- data.table::data.table(EZ[],
admin_labels,
dist_raster[])
# set column names, change as needed
names(EZ_strata) <- c("EZ_ID","strata1","strata2")
# reduce table down to a single row per EZ
EZ_strata <- na.omit(EZ_strata)
EZ_strata <- unique(EZ_strata)
# check we have the correct number of rows/EZs
nrow(EZ_strata)
# look at the top of the table
head(EZ_strata)
tail(EZ_strata)
EZ_tab <- merge(EZ_tab,EZ_strata,by="EZ_ID")
nrow(EZ_tab)
head(EZ_tab)
rm(list=ls())
EZ_tab <- read.csv(paste0(file_path_outputs, "EZ_Pop_Ncells_wsm_large.csv"),header=T)
file_path_inputs <- paste0(getwd(),"/data_wsm/made/")
# output
# check whether the output folder already exists - if not, create the folder
file_path_outputs <- paste0(getwd(),"/results_wsm/")
EZ_tab <- read.csv(paste0(file_path_outputs, "EZ_Pop_Ncells_wsm_large.csv"),header=T)
nrow(EZ_tab)
admin_raster <- terra::rast(paste0(file_path_inputs,"adminGADM.tif"))
settlement_raster <- terra::rast(paste0(file_path_inputs,"settGHS.tif"))
admin_cats <- terra::cats(admin_raster)[[1]]
admin_labels <- admin_cats$GID_2[match(admin_raster[], admin_cats$value)]
# as we defined the distance categories by numeric values, we can directly use those raster values
EZ_strata <- data.table::data.table(EZ[],
admin_labels,
settlement_raster[])
EZ <- terra::rast(paste0(file_path_outputs,"EZ_IDs_wsm_large.tif"))
admin_cats <- terra::cats(admin_raster)[[1]]
admin_labels <- admin_cats$GID_2[match(admin_raster[], admin_cats$value)]
# as we defined the distance categories by numeric values, we can directly use those raster values
EZ_strata <- data.table::data.table(EZ[],
admin_labels,
settlement_raster[])
# set column names, change as needed
names(EZ_strata) <- c("EZ_ID","strata1","strata2")
# reduce table down to a single row per EZ
EZ_strata <- na.omit(EZ_strata)
EZ_strata <- unique(EZ_strata)
nrow(EZ_strata)
plot(settlement_raster)
plot(EZ)
length(admin_labels)
length(EZ[])
length(admin_raster[])
length(settlement_raster[])
population_raster<-terra::rast(paste0(file_path,"popWP.tif"))
file_path <- paste0(getwd(),"/data_wsm/made/")
population_raster<-terra::rast(paste0(file_path,"popWP.tif"))
length(population_raster[])
EZ <- terra::rast(paste0(file_path_outputs,"EZ_IDs_wsm_large.tif"))
length(EZ[])
rm(list=ls())
# list of required packages
required_packages <- c("sf", "terra", "parallel", "data.table", "ggplot2", "scico", "patchwork")
# install missing packages
install.packages(setdiff(required_packages, installed.packages()[, "Package"]))
# load packages
library(sf)
library(terra)
library(data.table)
library(parallel)
library(ggplot2)
library(scico)
library(patchwork)
library(gridEZ2)
gc()
file_path <- paste0(getwd(),"/data_wsm/")
if (!dir.exists(paste0(file_path))) {
dir.create(file_path)
}
population_raster <- terra::rast(paste0(getwd(),"/data_wsm/wsm_pop_2025_CN_100m_R2025A_v1.tif"))
population_raster
plot(population_raster,main="Population distribution of Samoa (WorldPop data)")
settlement_raster <- terra::rast(paste0(getwd(),"/data_wsm/GHS_SMOD_E2025_GLOBE_R2023A_54009_1000_V2_0_R11_C2/GHS_SMOD_E2025_GLOBE_R2023A_54009_1000_V2_0_R11_C2.tif"))
plot(settlement_raster,main="Settlement categories (GHS-SMOD data)")
admin_sf <- sf::st_read(paste0(getwd(),"/data_WSM/gadm41_WSM_shp/gadm41_WSM_2.shp"))
# look at the list of fields in admin_sf
names(admin_sf)
# plot the "GID_2" field which contains the level 2 unit IDs
plot(admin_sf["GID_2"],main="Level 2 administrative units for Samoa (GADM data)")
# identify the CRS of the population raster
r_crs <- terra::crs(population_raster)
# if the strata layers have a different CRS, transform
if(r_crs !=sf::st_crs(admin_sf)){admin_sf <- sf::st_transform(admin_sf, r_crs)}
if(r_crs !=terra::crs(settlement_raster)){settlement_raster <- terra::project(settlement_raster,terra::crs(population_raster),method="near")}
# rasterize admin_sf
admin_raster <- terra::rasterize(admin_sf,population_raster,field="GID_2")
# remove admin_sf object as we no long need it
rm(admin_sf)
population_raster[is.na(population_raster)&!is.na(admin_raster)] <- 0
settlement_raster <- terra::crop(settlement_raster,admin_raster,snap="out",extend=TRUE)
plot(settlement_raster, main = "Settlement categories (GHS-SMOD data)")
# re-define categories
settlement_raster[settlement_raster %in% c(30,23,22,21)] <- 1 # urban
settlement_raster[settlement_raster %in% c(13,12,11)] <- 2 # rural
settlement_raster[settlement_raster == 10] <- NA #water
# re-plot
plot(settlement_raster, main = "Merged settlement categories (GHS-SMOD data)")
settlement_raster <- terra::resample(settlement_raster, population_raster, method = "near")
file_path <- paste0(getwd(),"/data_wsm/made/")
if (!dir.exists(paste0(file_path))) {
dir.create(file_path)
}
admin_raster
settlement_raster
population_raster
terra::writeRaster(admin_raster,paste0(file_path,"adminGADM.tif"))
terra::writeRaster(population_raster,paste0(file_path,"popWP.tif"))
terra::writeRaster(settlement_raster,paste0(file_path,"settGHS.tif"))
# remove all objects
rm()
# garbage collection
gc()
parallel::detectCores()
# we advise that you use your total number of cores minus 1 but you could use fewer (unless you only acces to one core, then you should specify 1 processing core)
processing_cores <- max(parallel::detectCores() - 1, 1)
processing_cores
file_path_inputs <- paste0(getwd(),"/data_wsm/made/")
# output
# check whether the output folder already exists - if not, create the folder
file_path_outputs <- paste0(getwd(),"/results_wsm/")
if (!dir.exists(paste0(file_path_outputs))) {
dir.create(file_path_outputs)
}
gridEZ2::gridEZ(population_raster_path = paste0(file_path_inputs,"popWP.tif"),
strata1_raster_path = paste0(file_path_inputs,"adminGADM.tif"),
strata2_raster_path = paste0(file_path_inputs,"settGHS.tif"),
predefined_EZ_size = TRUE,
EZ_target_size = "large",
output_path = paste0(file_path_outputs),
run_ID = "wsm_large",
ncores=processing_cores)
gridEZ2::gridEZ(population_raster_path = paste0(file_path_inputs,"popWP.tif"),
strata1_raster_path = paste0(file_path_inputs,"adminGADM.tif"),
strata2_raster_path = paste0(file_path_inputs,"settGHS.tif"),
predefined_EZ_size = FALSE,
target_pop_per_EZ = 1200,
max_cells_per_EZ = 2500,
output_path = paste0(file_path_outputs),
run_ID = "wsm_large_ownspecs",
ncores=processing_cores)
EZ_tab <- read.csv(paste0(file_path_outputs, "EZ_Pop_Ncells_wsm_large.csv"),header=T)
# number of EZs in your sampling frame
nrow(EZ_tab)
# the first rows
head(EZ_tab)
EZ_tab_ownspecs <- read.csv(paste0(file_path_outputs, "EZ_Pop_Ncells_wsm_large_ownspecs.csv"),header=T)
# number of EZs in your sampling frame
nrow(EZ_tab_ownspecs)
# the first rows
head(EZ_tab_ownspecs)
EZ <- terra::rast(paste0(file_path_outputs,"EZ_IDs_wsm_large.tif"))
EZ
?terra::extend
EZ1 <- terra::extend(EZ,admin_raster)
EZ1
EZ <- terra::extend(EZ,admin_raster)
rm(EZ1)
admin_cats <- terra::cats(admin_raster)[[1]]
admin_labels <- admin_cats$GID_2[match(admin_raster[], admin_cats$value)]
EZ_strata <- data.table::data.table(EZ[],
admin_labels,
settlement_raster[])
# set column names, change as needed
names(EZ_strata) <- c("EZ_ID","strata1","strata2")
# reduce table down to a single row per EZ
EZ_strata <- na.omit(EZ_strata)
EZ_strata <- unique(EZ_strata)
head(EZ_strata)
EZ
admin_raster
settlement_raster
length(admin_labels)
EZ_strata <- data.table::data.table(EZ[],
admin_labels,
settlement_raster[])
nrow(EZ_strata)
names(EZ_strata) <- c("EZ_ID","strata1","strata2")
EZ_strata <- na.omit(EZ_strata)
head(EZ_strata)
head(EZ[!is.na(EZ[])])
unique(admin_labels)
admin_cats <- terra::cats(admin_raster)[[1]]
admin_cats
head(admin_raster[!is.na(admin_raster)])
admin_labels <- admin_cats$GID_2[match(admin_raster[], admin_cats$value)]
names(admin_cats)
admin_labels <- admin_cats[match(admin_raster[], admin_cats[,1]),2]
length(admin_labels)
EZ_strata <- data.table::data.table(EZ[],
admin_labels,
settlement_raster[])
# set column names, change as needed
names(EZ_strata) <- c("EZ_ID","strata1","strata2")
# reduce table down to a single row per EZ
EZ_strata <- na.omit(EZ_strata)
EZ_strata <- unique(EZ_strata)
nrow(EZ_strata)
head(EZ_strata)
EZ_tab <- merge(EZ_tab,EZ_strata,by="EZ_ID")
# check number of rows/EZs
nrow(EZ_tab)
# look at the top of the table
head(EZ_tab)
table(EZ_tab$strata1)
table(EZ_tab$strata1,EZ_tab$strata2)
table(EZ_tab$strata2,EZ_tab$strata1)
ggplot(EZ_tab, aes(x = strata1, fill = strata2)) +
geom_bar(position = "dodge") +
labs(
x = "Stratum 1",
y = "Count",
fill = "Stratum 2"
) +
theme_minimal()
ggplot(EZ_tab, aes(x = strata1, fill = strata2)) +
geom_bar(position = "stack") +
labs(
x = "Stratum 1",
y = "Count",
fill = "Stratum 2"
) +
theme_minimal()
ggplot(EZ_tab, aes(x = strata1, fill = as.dactor(strata2))) +
geom_bar(position = "stack") +
labs(
x = "Stratum 1",
y = "Count",
fill = "Stratum 2"
) +
theme_minimal()
ggplot(EZ_tab, aes(x = strata1, fill = as.factor(strata2))) +
geom_bar(position = "stack") +
labs(
x = "Stratum 1",
y = "Count",
fill = "Stratum 2"
) +
theme_minimal()
ggplot(EZ_tab, aes(x = strata1, fill = as.factor(strata2))) +
geom_bar(position = "stack") +
labs(
x = "Admin. unit",
y = "Count",
fill = "Settlement type"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
)
plot(settlement_raster)
ggplot(EZ_tab, aes(x = strata1, fill = as.factor(strata2))) +
geom_bar(position = "stack") +
labs(
x = "Admin. unit",
y = "Count",
fill = "Settlement type"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
) +
scale_fill_discrete(labels = c("1" = "urban", "2" = "rural"))
ggplot(EZ_tab, aes(x = strata1, fill = as.factor(strata2))) +
geom_bar(position = "stack") +
labs(
title = "Count of EZs per stratum",
x = "Admin. unit",
y = "Count",
fill = "Settlement type"
) +
theme_minimal() +
theme(
axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1)
) +
scale_fill_discrete(labels = c("1" = "urban", "2" = "rural"))
library(knitr)
df <- data.frame(c("small","medium","large"),
c(75,500,1200),
c("50-100","333-667","800-1600"),
c(100,900,2500),
c(150,1350,3750))
colnames(df) <- c("Target EZ size","Target population size per EZ","Acceptable population range", "Target maximum grid cells per EZ", "Acceptable maximum grid cells per EZ")
knitr::kable(df)
0.75*150
100/150
library(knitr)
df <- data.frame(c(1:3),
c("WorldPop 2025 (R2025A version v1)","WorldPop 2025 (R2025A version v1) & GHS-POP 2025 (R2023A)","WorldPop 2025 (R2025A version v1)"),
c("Administrative units: GADM (v4.1)","Administrative units: GADM (v4.1)","Administrative units: GADM (v4.1)"),
c("Settlement type: GHS-SMOD 2025 (R2023A)","Settlement type: GHS-SMOD 2025 (R2023A)","Distance to coast"),
c("large","small, medium, large","large"),
c("both","pre-defined","pre-defined"))
colnames(df) <- c("Tutorial","Pop. data","Strata 1","Strata 2","EZ size","Pre- or user-defined specs")
knitr::kable(df)
c("WorldPop 2025 (R2025A version v1)","WorldPop 2025 (R2025A version v1) & GHS-POP 2025 (R2023A)","WorldPop 2025 (R2025A version v1)")
c("Administrative units: GADM (v4.1)","Administrative units: GADM (v4.1)","Administrative units: GADM (v4.1)")
c("Settlement type: GHS-SMOD 2025 (R2023A)","Settlement type: GHS-SMOD 2025 (R2023A)","Distance to coast")
c("large","small, medium, large","large")
df <- data.frame(c(1:3),
c("WorldPop 2025 (R2025A version v1)","WorldPop 2025 (R2025A version v1) & GHS-POP 2025 (R2023A)","WorldPop 2025 (R2025A version v1)"),
c("Administrative units: GADM (v4.1)","Administrative units: GADM (v4.1)","Administrative units: GADM (v4.1)"),
c("Settlement type: GHS-SMOD 2025 (R2023A)","Settlement type: GHS-SMOD 2025 (R2023A)","Distance to coast"),
c("large","small, medium, large","large"),
c("both","pre-defined","pre-defined"))
quarto::quarto_version()
library(quarto)
file_path_outputs <- paste0(getwd(),"/results_wsm/")
if (!dir.exists(paste0(file_path_outputs))) {
dir.create(file_path_outputs)
}
file_list <- list.files(paste0(file_path_outputs),full.names = TRUE)
file_list <- file_list[grepl("wsm_wp|wsm_ghs", file_list)]
res_poly_list <- lapply(split(thresholds_tab, seq_len(nrow(thresholds_tab))),function(x){
# read in summary table of sampling frame
file_name <- file_list[grepl(paste(x$popdata), file_list) & grepl(paste(x$EZsize), file_list) & grepl("\\.csv$", file_list)]
EZ_tab <- read.csv(paste(file_name),header=T)
# read in sampling frame raster
file_name <- file_list[grepl(paste(x$popdata), file_list) & grepl(paste(x$EZsize), file_list) & grepl("\\.tif$", file_list)]
EZ <- terra::rast(paste(file_name))
# convert to sf polygons
res_poly <- terra::as.polygons(EZ, dissolve = TRUE)
res_poly <- sf::st_as_sf(res_poly)
res_poly <- merge(res_poly,EZ_tab,by="EZ_ID")
res_poly$popdata <- x$popdata
res_poly$EZsize <- x$EZsize
res_poly$cat <- NA
res_poly$cat[res_poly$N<=x$uppermaxgeog & res_poly$pop>=x$minpop & res_poly$pop<=x$maxpop] <- 1
res_poly$cat[res_poly$N>=x$lowermaxgeog & res_poly$N<=x$uppermaxgeog & res_poly$pop<x$minpop] <- 2
res_poly$cat[res_poly$N==1 & res_poly$pop>x$maxpop] <- 3
res_poly$cat[res_poly$N>1 & res_poly$pop>x$maxpop] <- 4
res_poly$cat[res_poly$N<x$lowermaxgeog & res_poly$pop<x$minpop] <- 5
res_poly$cat[res_poly$N>x$uppermaxgeog] <- 6
res_poly
})
thresholds_tab <- data.table::data.table( popdata=rep(c("wp","ghs"),each=3), EZsize=rep(c("small","med","large"),2), minpop=rep(c(50,333,800),2), maxpop=rep(c(100,667,1600),2), lowermaxgeog=rep(c(75,675,1875),2), uppermaxgeog=rep(c(150,1350,3750),2) )
thresholds_tab
res_poly_list <- lapply(split(thresholds_tab, seq_len(nrow(thresholds_tab))),function(x){
# read in summary table of sampling frame
file_name <- file_list[grepl(paste(x$popdata), file_list) & grepl(paste(x$EZsize), file_list) & grepl("\\.csv$", file_list)]
EZ_tab <- read.csv(paste(file_name),header=T)
# read in sampling frame raster
file_name <- file_list[grepl(paste(x$popdata), file_list) & grepl(paste(x$EZsize), file_list) & grepl("\\.tif$", file_list)]
EZ <- terra::rast(paste(file_name))
# convert to sf polygons
res_poly <- terra::as.polygons(EZ, dissolve = TRUE)
res_poly <- sf::st_as_sf(res_poly)
res_poly <- merge(res_poly,EZ_tab,by="EZ_ID")
res_poly$popdata <- x$popdata
res_poly$EZsize <- x$EZsize
res_poly$cat <- NA
res_poly$cat[res_poly$N<=x$uppermaxgeog & res_poly$pop>=x$minpop & res_poly$pop<=x$maxpop] <- 1
res_poly$cat[res_poly$N>=x$lowermaxgeog & res_poly$N<=x$uppermaxgeog & res_poly$pop<x$minpop] <- 2
res_poly$cat[res_poly$N==1 & res_poly$pop>x$maxpop] <- 3
res_poly$cat[res_poly$N>1 & res_poly$pop>x$maxpop] <- 4
res_poly$cat[res_poly$N<x$lowermaxgeog & res_poly$pop<x$minpop] <- 5
res_poly$cat[res_poly$N>x$uppermaxgeog] <- 6
res_poly
})
file_list
list.files(paste0(file_path_outputs))
file_list
thresholds_tab
split(thresholds_tab, seq_len(nrow(thresholds_tab)))
x<-split(thresholds_tab, seq_len(nrow(thresholds_tab)))[[1]]
x
paste(x$popdata)
paste(x$EZsize)
file_name <- file_list[grepl(paste(x$popdata), file_list) & grepl(paste(x$EZsize), file_list) & grepl("\\.csv$", file_list)]
file_name
file_dir_outputs <- paste0(getwd(),"/results_wsm/")
if (!dir.exists(paste0(file_dir_outputs))) {
dir.create(file_dir_outputs)
}
file_dir_outputs
file_path_outputs <- paste0(getwd(),"/results_wsm/tutorial1/")
if (!dir.exists(paste0(file_path_outputs))) {
dir.create(file_path_outputs)
}
file_path_outputs <- paste0(getwd(),"/results_wsm/tutorial2/")
if (!dir.exists(paste0(file_path_outputs))) {
dir.create(file_path_outputs)
}
file_path_outputs <- paste0(getwd(),"/results_wsm/tutorial3/")
if (!dir.exists(paste0(file_path_outputs))) {
dir.create(file_path_outputs)
}
